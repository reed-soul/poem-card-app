# 飞渡 SDK - 进阶教程

本章节包含多个云渲染窗口嵌入、异步接口调用、事件系统、相机控制以及高性能 Tick 功能等进阶内容。

---

## 一、在一个页面中嵌入多个云渲染窗口

要在同一个页面中嵌入多个云渲染视频流窗口，目前有以下两种方式：

### 第1种方式：使用 iframe 框架

代码如下：（具体示例请参考：player_2_1.html）

```html
<body>
  <table width="100%" height="600" border="0">
    <tr>
      <td>
        <iframe id="player1" src="player.html?ms" width="100%" height="100%"></iframe>
      </td>
      <td>
        <iframe id="player2" src="player.html?ms" width="100%" height="100%"></iframe>
      </td>
    </tr>
  </table>
</body>
```

这种方式代码简单，适合快速开发展示多个视频流的情况，但是这种方式调用 DigitalTwinAPI 接口的时候比较繁琐，因为用到了 iframe 所以涉及到了跨域的问题，可以通过 postMessage 的方式实现，这里不详细讨论，我们主要介绍第2种方案。

### 第2种方式：（仅适用于 20210315 之后的版本）

HTML 核心代码如下：

```html
<div id="player1"></div><button onclick="callPlayer1()">调用Player1的接口</button>
<div id="player2"></div><button onclick="callPlayer2()">调用Player2的接口</button>
```

JS 核心代码如下：

```javascript
//注意：显卡要支持Cloud启动多个实例
let instanceId1 = '2464721833873';//实例id1 请在cloud实例列表中右键复制实例id
let instanceId2 = '2464721833874';//实例id2 请在cloud实例列表中右键复制实例id

let host = '127.0.0.1:8080';
let option1 = {
  //必选参数，网页显示视频流的domId
  'domId': 'player1',
  //实例id
  'iid': instanceId1,
  //必选参数，二次开发时必须指定，否则无法进行二次开发
  'apiOptions': {
    //必选参数，与云渲染主机通信成功后的回调函数
    //注意：只有在onReady之后才可以调用DigitalTwinAPI接口
    'onReady': _onReady1
  }
};
let option2 = {
  //必选参数，网页显示视频流的domId
  'domId': 'player2',
  //实例id
  'iid': instanceId2,
  //必选参数，二次开发时必须指定，否则无法进行二次开发
  'apiOptions': {
    //必选参数，与云渲染主机通信成功后的回调函数
    //注意：只有在onReady之后才可以调用DigitalTwinAPI接口
    'onReady': _onReady2
  }
};
//根据不同实例id初始化两个api对象
var __api1 = new DigitalTwinPlayer(host, option1).getAPI();
var __api2 = new DigitalTwinPlayer(host, option2).getAPI();

//例子：隐藏各自的右侧ui
function callPlayer1() {
  __api1.settings.setMainUIVisibility(false);
}
function callPlayer2() {
  __api2.settings.setMainUIVisibility(false);
}
```

具体示例代码请参考：player_2_2.html

---

## 二、异步接口三种调用方式

DigitalTwinAPI 的接口大部分都是异步的，所以在调用的时候需要进行特殊处理，否则可能因为调用错误而不能实现预期的效果。目前有三种异步接口的调用方式，DigitalTwinAPI 同时支持这 3 种方式，需要注意的是：**在一个函数体内，这 3 种方式不能混合使用，只能选择其中一种。**

### 方式一：使用 callback 回调函数进行调用

这是最先支持的一种方式，代码逻辑简单，容易理解，但是当一个函数体内调用的异步接口比较多的时候，代码可读性变差，维护比较麻烦，在下面的例子里可以看到使用了多个嵌套函数，括号太多，比较混乱。

```javascript
fdapi.tag.delete('tag1', function () {
  fdapi.camera.get(function (cam) {
    let o = new TagData('tag1');
    o.coordinate = [cam.x, cam.y, 25.4];
    o.imagePath = HostConfig.Path + '/samples/images/tag.png';
    o.imageSize = [28, 28];
    o.text = '北京银行';
    o.showLine = true;
    fdapi.tag.add(o, function () {
      fdapi.tag.focus(o.id, 500, 0.2, function () {
        log("Test Finished.");
      }); //focus
    }); //add
  }) //get
}); //delete
```

### 方式二：使用 then 链的方式调用

这种方式通过连续的 then 调用来解决函数嵌套问题，可读性比回调的方式要好一些。

```javascript
fdapi.tag.delete('tag1').then(() => fdapi.camera.get())
  .then((cam) => {
    let o = new TagData('tag1');
    o.coordinate = [cam.x, cam.y, 25.4];
    o.imagePath = HostConfig.Path + '/samples/images/tag.png';
    o.imageSize = [28, 28];
    o.text = '北京银行';
    o.showLine = true;
    fdapi.tag.add(o);
  })
  .then(() => fdapi.tag.focus('tag1', 500, 0.2))
  .then(() => {
    log("Test Finished.");
  })
```

### 方式3：使用 async/await 的异步方式调用

这种方式其实是第 2 种方式的语法糖，但是可读性大大提高。

```javascript
await fdapi.tag.delete('tag1')
let cam = await fdapi.camera.get();

let o = new TagData('tag1');
o.coordinate = [cam.x, cam.y, 25.4];
o.imagePath = HostConfig.Path + '/samples/images/tag.png';
o.imageSize = [28, 28];
o.text = '北京银行';
o.showLine = true;
await fdapi.tag.add(o);
await fdapi.tag.focus(o.id, 500, 0.2);
log("Test Finished.");
```

**重要提示：** 如果不使用异步调用（去掉所有的 await 或 then），接口调用顺序会混乱，无法达到预期效果。异步接口是按顺序执行的，每调用一次接口，都是收到服务器返回数据后才会往下继续执行下一次异步接口。

---

## 三、事件交互系统

### 3.1 内置交互事件名称及监听说明

#### 初始化 API 时根据回调函数监听

初始化 API 时监听，示例代码如下：

```javascript
//场景交互事件回调函数，默认构造参数event即为事件对象
function onEvent(event) {
  //事件类型 参考交互事件类型枚举对象
  var eventType = event.eventtype;
  //图层类型
  var layerType = event.Type;
  //图层Id
  var layerId = event.Id || event.ID;
  //点击ActorId
  var objectId = event.ObjectID;
  //当前点击位置
  var objectLocation = event.MouseClickPoint;

  switch (eventType) {
    //鼠标左键点击时触发此事件
    case "LeftMouseButtonClick":
      log('触发事件类型：鼠标左键单击，eventType：' + eventType);
      break;

    //鼠标悬停时触发此事件
    //注意需提前开启鼠标拾取：fdapi.settings.setMousePickMask(7);
    case "MouseHovered":
      log('触发事件类型：鼠标悬停，eventType：' + eventType);
      break;

    //鼠标移动时触发此事件
    //注意需提前开启鼠标拾取：fdapi.settings.setMousePickMask(7);
    case "MouseMoved":
      log('触发事件类型：鼠标移动，eventType：' + eventType);
      break;

    //相机开始移动时触发此监听事件
    //注意需先开启事件：fdapi.settings.setEnableCameraMovingEvent(true);
    case "CameraStartMove":
      log('触发事件类型：相机开始飞行，eventType：' + eventType);
      break;

    //相机正在移动时触发此监听事件
    //注意需先开启事件：fdapi.settings.setEnableCameraMovingEvent(true);
    case "CameraMoving":
      log('触发事件类型：相机正在飞行，eventType：' + eventType);
      break;

    //相机停止移动时触发此监听事件
    //注意需先开启事件：fdapi.settings.setEnableCameraMovingEvent(true);
    case "CameraStopMove":
      log('触发事件类型：相机停止飞行，eventType：' + eventType);
      break;

    //对象执行focus()或相机执行set()/lookAt()/lookAtBBox()方法时触发
    case "CameraChanged":
      log('触发事件类型：相机位置发生变化，eventType：' + eventType);
      break;

    //进入面剖切模式，编辑面剖切位置后触发事件并返回剖切结果
    case "PlaneClipEdit":
      log('触发事件类型：编辑面剖切，eventType：' + eventType);
      break;

    //进入体剖切模式，编辑体剖切位置后触发事件并返回剖切结果
    case "VolumeClipEdit":
      log('触发事件类型：编辑体剖切，eventType：'+ eventType);
      break;

    //进入测量模式后，测量完成时触发此事件并返回测量结果
    case "Measurement":
      log('触发事件类型：测量完成，eventType：' + eventType);
      break;

    //播放导览结束触发此事件
    //fdapi.camera.playAnimation(id)和导览对象播放导览结束__g.cameraTour.play(id)均触发此事件
    case "CameraTourFinished":
      log('触发事件类型：播放导览结束，eventType：' + eventType);
      break;

    default:
      ""
  }
}

//视频流初始化配置
let options = {
  //必选参数，网页显示视频流的dom节点id
  'domId': 'player',
  //必选参数，二次开发时必须指定，否则无法进行二次开发
  'apiOptions': {
    //事件监听回调函数
    'onEvent': onEvent,
  },
  ...
};
//构造DigitalTwinAPI对象并初始化
let acapi = new DigitalTwinPlayer('127.0.0.1:8080', options).getAPI();
```

### 3.2 通过 API 接口设置监听事件

初始化 API 完成后，调用 API 方法进行事件监听设置，代码示例如下：

```javascript
//通过API接口设置监听事件 注意：使用此方式监听事件会覆盖上一次设置的事件监听代码
fdapi.setEventCallback(function (event) {
  //事件类型 参考交互事件类型枚举对象
  var eventType = event.eventtype;
  //图层类型
  var layerType = event.Type;
  //图层Id
  var layerId = event.Id || event.ID;
  //点击ActorId
  var objectId = event.ObjectID;
  //当前点击位置
  var objectLocation = event.MouseClickPoint;
  //TODO...

});
```

### 3.3 自定义监听鼠标、键盘

自定义键盘鼠标交互：

DigitalTwinPlayer 的初始化参数 params 增加属性：actionEventHander，可以用来设置键盘、鼠标交互事件的回调函数，目前支持以下事件的回调：

- onmouseenter //鼠标进入 获取焦点
- onmouseleave //鼠标离开 失去焦点
- onmousemove //鼠标移动
- onmousedown //鼠标按下
- onmouseup //鼠标松开
- onkeydown //键盘按下
- onkeyup //键盘松开

```javascript
let actionEventHander = {
  'onmousedown': e => { log(`[MouseDn] button: ${e.button}, pos: ${e.x}, ${e.y}`) },
  'onmouseup': e => { log(`[MouseUp] button: ${e.button}, pos: ${e.x}, ${e.y}`) },
  'onkeydown': e => { log(`KeyDown: ${e.code}`) }
}
aircityPlayer = new DigitalTwinPlayer("127.0.0.1:8080", {
  'actionEventHander': actionEventHander //鼠标、键盘交互事件的回调
  //其他属性
  //...
});
```

**运行效果：**
```
[MouseDn] button: 2, pos: 892, 625
[MouseUp] button: 2, pos: 892, 625
KeyDown: KeyF
KeyDown: KeyA
KeyDown: KeyD
KeyDown: ControlLeft
KeyDown: ShiftLeft
```

---

## 四、关于设置相机位置的几种方式

在 int.html 页面中点击 Camera Get 可以看到输出信息如下：

我们可以通过三种参数形式来调用 camera.set 方法。

### 方式一：普通方式

这是最常见的调用方式，代码如下：

```javascript
function test_camera_set() {
  //参数：x, y, z, pitch, yaw, flyTime
  fdapi.camera.set(492035.37, 2488806.75, 402.62, -15.0, -173.0, 0.2);
}
```

### 方式二：通过 Object 参数的形式

可以直接复制 camera.get 的输出：

```javascript
function test_camera_set_byObject() {
  let cam = {
    "x": 490088.281250,
    "y": 2485978.750000,
    "z": 1031.461914,
    "pitch": -39.462357,
    "yaw": -152.668823,
    "roll": 0.0 //该参数无用，会自动忽略
  }
  fdapi.camera.set(cam, 0.2);
}
```

### 方式三：通过 Array 参数的形式

可以直接复制 camera.get 输出里的 camera 数组来设置：

```javascript
function test_camera_set_byArray() {
  //最后一个元素无用，会忽略
  let cam = [488586.843750, 2486889.750000, 713.141602, -36.353725, -124.556442, -0.000004];
  fdapi.camera.set(cam, 0.2);
}
```

---

## 五、DigitalTwinAPI 之 tick 功能使用说明

### 5.1 功能简介

tick 功能提供了一种高性能的 DigitalTwinAPI 接口调用方式。

常规的 DigitalTwinAPI 调用流程是这样的：客户端调用 DigitalTwinAPI（通过网络传输），后台渲染进程接收命令，然后进行异步处理。这样就有几个方面的延迟：

1. 客户端的异步等待（命令发送后等待返回结果）
2. 网络传输（通过 WebRTC）
3. 后台渲染进程的线程切换（接收线程收到数据后，投递到执行线程，执行线程处理后投递到发送线程）

通过上面的流程可以看到如果高频率的调用接口，性能是不会太高的。为了解决这一问题，实现了 tick 功能。通过 tick 功能，可以在渲染进程的每帧直接同步地调用 DigitalTwinAPI，极大的提高了调用性能。

### 5.2 实现原理

tick 功能是通过渲染进程内嵌的 chrome 浏览器内核（cef）执行 JS 脚本达到目的的。

调用注册接口后，进程会创建一个 cef 浏览器引擎，参数 url 将被设置为浏览器要显示的页面，在此页面内的 DigitalTwinAPI 调用，都是在同进程直接调用底层 C++ 接口的，C++ 处理完成后，通过回调 cef 页面的 Javascript 函数来通知 JS 进行后续操作。由于是在同一个进程内进行 JS/C++ 互操作，所以性能非常高。

### 5.3 使用详解

#### 1、接口说明

总共有 4 个方法：

##### registerTick

registerTick 用于注册 tick 功能，注意：全局只能注册一个 tick 页面，多次 registerTick，后面的 tick 功能会覆盖掉前面的。参数说明：

- **url**
  tick 功能是通过一个独立的 html 页面实现的，此参数用来设置页面的地址。注意：由于是在后台渲染进程执行，所以页面地址必须是完整的网络路径或者服务器上的本地绝对路径，不能传递相对路径。

- **options**
  用来设置是否显示调试页面，由于 cef 调试 JS 比较麻烦，所以可以设置此参数，将调试信息在页面上显示，这样就极大的方便了代码调试。options 支持以下属性（可设置一个或多个属性，未设置的属性会使用默认值）：

  - **x**：调试窗口距离左上角的 X 偏移量。默认值 4
  - **y**：调试窗口距离左上角的 Y 偏移量。默认值 4
  - **width**：调试窗口的宽度。默认值 400
  - **height**：调试窗口的高度。默认值 300
  - **visible**：是否可见。默认为 false（不可见）

#### removeTick

removeTick 用于移除 tick 功能，调用此方法后，tick 功能会停止。

#### showTickWindow

showTickWindow 用于显示/隐藏调试窗口。此方法既可以在客户端调用，也可以在 tick 页面调用。

#### executeJsInTickPage

executeJsInTickPage 用于实现客户端页面与 tick 页面的通信，通过此方法，可以在客户端页面执行 tick 页面的 JS 代码。

客户端页面和 tick 页面（服务器页面）之间可以双向通信，在 tick 页面调用 `ue.internal.postevent("str")`，可以实现 tick 页面向客户端页面发送消息。

#### 2、tick 页面说明

在 tick 页面里调用 DigitalTwinAPI 与常规调用有一些区别，主要体现在以下几个方面：

##### （1）DigitalTwinAPI 初始化

```javascript
var fdapi;
window.onload = function () {
  fdapi = new DigitalTwinAPI();
}
```

一般在 onload 里初始化，与常规初始化不同，tick 页面里初始化 DigitalTwinAPI 不需要传递任何参数。注意：这里也可以使用异步操作例如：

```javascript
window.onload = async function () {
  fdapi = new DigitalTwinAPI();
  await fdapi.tag.delete(id);
  await fdapi.tag.add(data);
}
```

##### （2）两个固定方法

```javascript
function tick(frameNo) {
  let data = fdapi.tag.setText(id, 'Tag:' + (i++).toString(), null);
  document.getElementById('r1').innerText = `[Frame:${frameNo}] ` + JSON.stringify(data);
}

function tick_next(o, frameNo) {
  if (o.command == CommandType.Tag_Update) {
    fdapi.tag.get(id, null);
  }
  else if (o.command == CommandType.Tag_Get) {
    document.getElementById('r2').innerText = `[Frame:${frameNo}] ` + JSON.stringify(o);
  }
}
```

tick 页面里有 2 个被底层调用的固定方法：tick 和 tick_next，这 2 个方法构成一个闭环。

- **tick**
  参数 frameNo，是当前帧号
  是主页面调用 registerTick 后，渲染进程在每帧都会回调的方法。

- **tick_next**
  可选的方法
  参数 o：是调用的 DigitalTwinAPI 接口的执行结果，通过此 o.command 可以知道 tick_next 是哪个接口执行完后返回的
  参数 frameNo，是当前帧号

  如果在 tick 里调用了 DigitalTwinAPI 的接口，渲染进程执行完后，由 tick_next 通知。如果不需要接口的返回值，可以不实现此方法。

**在 tick 和 tick_next 里调用 DigitalTwinAPI 有以下几个注意事项：**

- 在 tick 和 tick_next 方法里调用接口，要想获取接口返回值，接口的最后一个参数 fn 必须设置为 null，例如下面的代码：

```javascript
fdapi.tag.setText(id, 'Tag:' + (i++).toString(), null);
```

用于每帧设置标签文本，同时希望收到底层设置完以后的通知，那么就把最后一个参数设置为 null，底层设置完后会调用 tick_next 方法，tick_next 的参数就是详细的执行结果。

- 如果把最后一个参数设置为 null，那么该 API 调用后的方法返回值是 JS 层包装的将要传递到底层的 JSON 命令对象，具体请看下面实例运行结果。

- 如果不关心底层处理结果，可以不用设置最后一个参数为 null，例如：

```javascript
fdapi.tag.setText(id, 'Tag:' + (i++).toString());
```

此方法没有将最后一个参数设置为 null，那么底层执行完后，将不会调用 tick_next。

- 如果将最后一个参数设置为 null，那么 tick 和 tick_next 和底层的任务执行都是在同一个线程，也就是同步调用，所以性能很高。但是如果没有设置最后一个参数为 null，那就跟常规调用一样，是异步的，这时如果使用异步调用的 3 种方式去等待执行结果，会严重影响性能，失去了 tick 的意义！

**tick 页面完整示例：**

```html
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>TICK</title>
  <script type="text/javascript" src="../../ac_conf.js"></script>
  <script type="text/javascript" src="../../ac.min.js"></script>
  <style type="text/css">
    body {
      font-family: Verdana, Geneva, Tahoma, sans-serif;
      font-size: 9pt;
      background-color: rgb(199, 237, 204);
      overflow: scroll;
    }
  </style>
</head>
<body>
  <strong>Test Debug Window</strong>
  <a href="javascript:fdapi.tag.delete(id)">DeleteTag</a>
  <a href="javascript:ue.internal.postevent('test string')">PostEvent</a>
  <a href="javascript:fdapi.showTickWindow(false);">Close</a>
  <hr>
  <span id="r1"></span>
  <hr>
  <span id="r2"></span>
  <hr>
  <span id="r3"></span>
</body>
</html>
<script>
  var fdapi;
  var id = 'testTag';
  var i = 0;

  var data = {
    id: id,
    coordinate: [493217, 2491901, -1.9],
    text: 'Tag:0',
    textSize: 20,
    textColor: Color.Yellow,
    range: [1, 10000],
    showLine: false
  }

  window.onload = function () {
    fdapi = new DigitalTwinAPI();
    fdapi.tag.delete(id);
    fdapi.tag.add(data, o => {
      document.getElementById('r3').innerText = 'tag created.'
      fdapi.tag.focus(id, 100, 0);
    });
  }

  function clientCalled(str) {
    document.getElementById('r3').innerText = str;
  }

  function tick(frameNo) {
    let data = fdapi.tag.setText(id, 'Tag:' + (i++).toString(), null);
    document.getElementById('r1').innerText = `[Frame:${frameNo}] ` + JSON.stringify(data);
  }

  function tick_next(o, frameNo) {
    if (o.command == CommandType.Tag_Update) {
      fdapi.tag.get(id, null);
    }
    else if (o.command == CommandType.Tag_Get) {
      document.getElementById('r2').innerText = `[Frame:${frameNo}] ` + JSON.stringify(o);
    }
  }
</script>
```

上面代码实现的功能是：每帧改变标签的值，然后获取该标签的信息，在 tick 页面上显示出来。
